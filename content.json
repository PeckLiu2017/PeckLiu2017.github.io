[{"title":"Ruby元编程笔记—— 方法","date":"2017-09-19T11:10:04.000Z","path":"2017/09/19/Ruby元编程笔记——-方法/","text":"在理解了方法查找的基础上，可以在运行时创建方法、插入方法调用、把调用转发给其他对象，甚至调用一个不存在的方法。 对每一次方法调用，静态语言的编译器都会检查接收对象是否有一个匹配的方法，称之为静态类型检查（static type checking）。动态语言——比如Python和Ruby，没有静态类型检查（static type checking），这是进行元编程的基础。 元编程的好处：本章的元编程技术可以使代码更加简洁，也有利于代码更新和维护。 先来看一段代码，通过重构的过程，逐步了解元编程怎样发挥作用。 这是一个连接数据库并查询相关信息的data_source类。为节省时间，可直接跳到第三步重构步骤，需要回来看再跳回来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class DS # attr_accessor :workstation_id def initialize &quot;...connect...&quot; end def get_cpu_info(workstation_id) cpu_info = if workstation_id == 1 &quot;intel core i7&quot; else workstation_id == 2 &quot;apple AM 11&quot; end end def get_cpu_price(workstation_id) cpu_price = if workstation_id == 1 2500 else workstation_id == 2 2000 end end def get_mouse_info(workstation_id) mouse_info = if workstation_id == 1 &quot;雷蛇&quot; else workstation_id == 2 &quot;牧马人&quot; end end def get_mouse_price(workstation_id) mouse_price = if workstation_id == 1 300 else workstation_id == 2 500 end end def get_keyboard_info(workstation_id) keyboard_info = if workstation_id == 1 &quot;机械键盘&quot; else workstation_id == 2 &quot;普通键盘&quot; end end def get_keyboard_price(workstation_id) keyboard_price = if workstation_id == 1 500 else workstation_id == 2 90 end endend 这是一个computer类。 12345678910111213141516171819202122232425262728293031323334require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def mouse info = @data_source.get_mouse_info(@id) price = @data_source.get_mouse_price(@id) result = &quot;Mouse: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def cpu info = @data_source.get_cpu_info(@id) price = @data_source.get_cpu_price(@id) result = &quot;Cpu: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def keyboard info = @data_source.get_keyboard_info(@id) price = @data_source.get_keyboard_price(@id) result = &quot;Keyboard: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 endendcomputer = Computer.new(1,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 现在我们使用元编程的技术对Computer类增加动态派发，进行第一次重构： 12345678910111213141516171819202122232425262728293031require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def mouse component :mouse end def cpu component :cpu end def keyboard component :keyboard end def component(name) info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 首先把重复的代码提取到一个方法中，然后把mouse，cpu，keyboard方法代理到component方法上。component方法会接着调用DS类的get_XXX_info和get_XXX_price方法。然后执行相关操作。 现在重复代码被消灭了很多，但仍然可以进一步精简。 什么是动态派发？ 在代码运行的最后一刻再决定调用哪个方法，被称为动态派发。比如@datasource.send “get#{name}_info”, @id的使用。 现在我们使用define_method方法来动态创建方法，以进行第二次重构： 12345678910111213141516171819202122232425require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def self.define_component(name) define_method(name) do info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end end define_component :mouse # 调用第一次创建mouse方法 define_component :cpu # 调用第二次创建cpu方法 define_component :keyboard # 调用第三次创建keyboard方法endcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard define_method可以代替def关键字定义方法，这次重构中，self.define_component(name)方法执行了三次，每一次又都调用define_method分别创建了mouse ，cpu，keyboard方法。然后执行相关操作。 这三个在运行时被定义的方法被称为动态方法。 接下来又有一个关于代码维护和拓展的问题：如果将来DS类中加入了get_display_info方法，而Computer类中并没有动态派发这个方法，能不能在不修改Computer代码的基础上，自动将get_display_info方法加入到Computer的动态派发中呢？ 用内省的方式第三次重构，： 1234567891011121314151617181920212223require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source data_source.methods.grep(/^get_(.*)_info$/)&#123; Computer.define_component $1 &#125; end def self.define_component(name) define_method(name) do info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 这次重构中新加入的data_source.methods.grep(/^get_(.*)_info$/){ Computer.define_component $1 }的作用如下： 当程序执行到puts computer.mouse时，会去Computer类中去找mouse方法，在initialize中，data_source.methods.grep(/^get_(.*)_info$/)如果找到get_mouse_info方法就会用mouse作为参数传给Computer.define_component，随后Computer.define_component会创建mouse方法。 上面的三次重构用到了动态派发和动态方法的技术。接下来是运用幽灵方法和动态代理来解决代码重构的问题。 第四次重构： 1234567891011121314151617181920212223242526require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def method_missing(name) super if !@data_source.respond_to?(&quot;get_#&#123;name&#125;_info&quot;) info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def respond_to_missing?(method, include_private = false) @data_source.respond_to?(&quot;get_#&#123;method&#125;_info&quot;) || super endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboardputs computer.respond_to?(:mouse) 当程序执行到puts computer.mouse时，因为computer中没有直接定义mouse方法，所以会调用method_missing方法，如果在@data_source中找到了get_mouse_info，就会用mouse作为参数动态派发get_mouse_info和get_mouse_price执行相应程序返回相应结果。 什么叫幽灵方法？ method_missing 被称作幽灵方法，它可以动态地创建方法。 什么叫动态代理？ 一个捕获幽灵方法调用并把它们转发给另外一个对象的对象（有时也会在转发前后包装一些自己的逻辑，在这里指自己重写的method_missing方法），称为动态代理（Dynamic Proxy）。 当一个幽灵方法和一个真实方法发生名字冲突时这个问题是动态代理技术的通病，当一个幽灵方法和一个真实方法发生名字冲突时，后者会胜出。为了解决这个问题，你可以通过继承白板类和删除重名方法的方法来定义方法。 继承白板类: 1class XXX &lt; BasicObject 删除重名方法: 可以使用Module#undef_method()方法，它会删除所有的（包括继承来的）方法；也可以使用Module#remove_method()方法，它只会删除接收者自己的方法，而保留继承来的方法。","tags":[{"name":"Ruby元编程笔记","slug":"Ruby元编程笔记","permalink":"https://peckliu2017.github.io/tags/Ruby元编程笔记/"}]},{"title":"2017.4.13 ORID","date":"2017-04-13T03:05:44.000Z","path":"2017/04/13/2017-4-13-ORID/","text":"Objective知识点1： js能干什么？ 改变HTML内容,eg: 1&lt;button type=&quot;button&quot; onclick=&apos;document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello JavaScript!&quot;&apos;&gt;Click Me!&lt;/button&gt; 改变HTML属性,eg: 1&lt;button onclick=&quot;document.getElementById(&apos;myImage&apos;).src=&apos;pic_bulbon.gif&apos;&quot;&gt;Turn on the light&lt;/button&gt; 改变css样式,eg: 1&lt;button type=&quot;button&quot; onclick=&quot;document.getElementById(&apos;demo&apos;).style.fontSize=&apos;35px&apos;&quot;&gt;Click Me!&lt;/button&gt; Hide/Show HTML元素。 1234&lt;button type=&quot;button&quot; onclick=&quot;document.getElementById(&apos;demo&apos;).style.display=&apos;none&apos;&quot;&gt;Click Me!&lt;/button&gt;&lt;button type=&quot;button&quot; onclick=&quot;document.getElementById(&apos;demo&apos;).style.display=&apos;block&apos;&quot;&gt;Click Me!&lt;/button&gt;#or&lt;button type=&quot;button&quot; onclick=&quot;document.getElementById(&apos;demo&apos;).style.display=&apos;inline&apos;&quot;&gt;Click Me!&lt;/button&gt; 知识点2：js可以在什么位置插入？ js可以被安插在head,body元素中。 外部文件中： 123&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;Try it&lt;/button&gt;&lt;p&gt;(myFunction is stored in an external file called &quot;myScript.js&quot;)&lt;/p&gt;&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt; 外部URL中： 123&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;Try it&lt;/button&gt;&lt;p&gt;(myFunction is stored in an external file called &quot;myScript.js&quot;)&lt;/p&gt;&lt;script src=&quot;https://www.w3schools.com/js/myScript.js&quot;&gt; 外部文件夹中： 123&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;Try it&lt;/button&gt;&lt;p&gt;(myFunction is stored in an external file called &quot;myScript.js&quot;)&lt;/p&gt;&lt;script src=&quot;/js/myScript.js&quot;&gt;&lt;/script&gt; 知识点3什么是XMLHttpRequest？XMLHttpRequest 对象用于在后台与服务器交换数据。 知识点4：click和onclick的区别。在这种情况下，click无效果，onclick有效果。12345678910111213&lt;head&gt;&lt;script&gt;function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;Paragraph changed.&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=&quot;demo&quot;&gt;A Paragraph.&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;Try it&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 知识点5什么是同步和异步？阻塞和非阻塞？ 知乎上浪子的回答是这样的：假如你要做两件事，烧水、刷牙同步：你烧水，等水烧开了你再去刷牙异步：你烧水，不等水烧开就去刷牙了，水烧开了会发出声音告诉你（callback），然后你再处理水烧开之后的事情。只要你是个正常人，都会选择第二种董飞的回答是这样的：阻塞/同步：打一个电话一直到有人接为止非阻塞：打一个电话没人接，每隔10分钟再打一次，知道有人接为止 当然也有其他很多的回答，但一个具体的回答即使生动形象，也无法使我在我需要时自动就想到去用这个知识点。所以我对于这四个概念的理解是，当我为了提高效率去完成代码，就会自动从同步到异步，从阻塞到非阻塞了。所以，要在平时注重效率提升，多了解运行原理。这个概念以后还会不断更新，姑且先写到这里。他们的回答实在精彩，所以贴在上面。 知识点6javascript的输出： Writing into an window alert box #alert(…)； Writing into the HTML output #document.write(5 + 6); Writing into an HTML element #document.getElementById(“demo”).innerHTML = 5 + 6; Writing into the browser console #console.log(5 + 6); 知识点7下面这段代码中，”person.firstName”的”firstName”不能是数字。12345678910111213141516&lt;html&gt;&lt;body&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var person = &#123; firstName : &quot;John&quot;, lastName : &quot;Doe&quot;, age : 50, eyeColor : &quot;blue&quot;&#125;;document.getElementById(&quot;demo&quot;).innerHTML =person.firstName + &quot; is &quot; + person.age + &quot; years old.&quot;;#或者document.getElementById(&quot;demo&quot;).innerHTML = person[&quot;firstName&quot;] + person[&quot;lastName&quot;];&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 知识点8记一段函数：1234567891011121314151617&lt;p id=&quot;demo1&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo2&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo3&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo4&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo5&quot;&gt;&lt;/p&gt;&lt;script&gt;var y = 5; # y = 5var x = ++y; # y = 6var y = y; # y = 6var z = y++; # y = 7var y = y; # y = 7document.getElementById(&quot;demo1&quot;).innerHTML = &quot;y=&quot;+y; #所以这里输出y=7document.getElementById(&quot;demo2&quot;).innerHTML = &quot;x=&quot;+x;document.getElementById(&quot;demo3&quot;).innerHTML = &quot;y=&quot;+y;document.getElementById(&quot;demo4&quot;).innerHTML = &quot;z=&quot;+z;document.getElementById(&quot;demo5&quot;).innerHTML = &quot;y=&quot;+y;&lt;/script&gt; 输出结果：&gt;y=7x=6y=7z=6y=7 “y++”和”++y”的相同之处在于y都+1了，不同之处在于y=5时，x=++y=6，x=y++=5； 12345678910&lt;script&gt;var person = &#123; firstName: &quot;John&quot;, lastName : &quot;Doe&quot;, id : 5566, fullName : function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;;document.getElementById(&quot;demo&quot;).innerHTML = person.fullName; 输出： function () { return this.firstName + “ “ + this.lastName; }js中“类”一般用“{}”，数组用“[]”。 最后一句若是1document.getElementById(&quot;demo&quot;).innerHTML = person.fullName(); 输出：John Doe Reflective略 Interpretive略 Decisional略","tags":[{"name":"JS学习笔记","slug":"JS学习笔记","permalink":"https://peckliu2017.github.io/tags/JS学习笔记/"}]},{"title":"2017.4.11 ORID","date":"2017-04-11T17:10:25.000Z","path":"2017/04/12/2017-4-11-ORID/","text":"Objective 今天要记录什么? CSS有position和overflow属性。关于footer的布局 知识点一：将footer固定在浏览器页面的最底部。 页面的布局是这样的： 123456789&lt;body&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;%= render &quot;common/navbar&quot; %&gt; &lt;%= render &quot;common/flashes&quot; %&gt; &lt;%= yield %&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt; &lt;%= render &apos;common/footer&apos; %&gt; &lt;/body&gt; 如果footer上面内容不够一页，footer就直接显示在浏览器底部。不是像这样： 而是像这样：解决思路是把body设为高度100%，然后把footer固定在它底部就可以了。1234567891011121314body &#123; height: 100%; margin: 0; padding: 0;&#125;同时，.main &#123; padding-bottom: 100px; margin-bottom: 10%;&#125;footer &#123; height: 10%; margin-top: -100px;&#125; （最好用百分比高度，因为浏览器窗口大小问题可能导致CSS样式效果发生改变。）为什么要有这一步呢，因为： CSS盒子中margin的属性，main元素是空的，但它的margin部分可以把footer的内容包含。想要留白将footer置于底部，这里的情况是使用padding-bottom把\bfooter同上面的文字内容分开，padding-bottom=footer的height。 知识点二：撑大父元素。HTML布局如上，但发现问题，body并没有100%的高度，子元素footer\b跑到父元素body外面去了：原因是body中的子元素没有把body父元素“自动撑大”。解决方法是在body父元素中增加overflow属性，overflow规定溢出：123456body &#123; height: 100%; margin: 0; padding: 0; overflow: scroll;&#125; 然后父元素body被撑大到包含footer了。 知识点三：position属性。如果数据较多，显示内容超过一页，又将footer的position设为absolute，到了一页的末尾，有可能发生footer盖住上面内容的情况： Reflective 暂无。 Interpretive 今天一个重要的领悟是什么? 实践是最好的学习，至于自己实际做出来，才知道会遇到哪些坑，以后决不能有一点侥幸心理，遇到代码，全部必须自己敲出来。 Decisional 我们会如何用一句话形容今天的工作时间投入不够 有哪些工作需要明天继续努力?早起，上下午至少各3小时用于学代码。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://peckliu2017.github.io/tags/CSS/"}]},{"title":"2017.4.8 ORID——Job-Listing小型工作招聘网站的思路总结","date":"2017-04-07T17:15:35.000Z","path":"2017/04/08/2017-4-8-ORID/","text":"Objective：一个问题引发的思考——要拥有思考的能力：自己做job-listing的功能开发时感到苦难重重，但看到job-listing的答案代码时，感到”原来这么简单！我怎么没想到呢？对啊，为什么很简单功能变化一下，搭配一下我却想不到呢“？看起来很简单，做起来却这么难，这其中的差别在于什么呢？差别应该在于教材上所说的”迁移能力“，或者说笑来老师所说的”把问题分解再组合起来的能力——归纳分析总结能力了”。不运用归纳分析能力的思考过程是这样的： 目标=&gt;&gt;对问题理解一知半解,没搞明白就做=&gt;&gt;想到了一点头绪，做了一部分工作=&gt;&gt;想做这个又想要那个或者想不下去了==&gt;工作量太大超出能力范围and接下来有点难了==&gt;只能或者只会做这么多了（其实是只能想这么多了）=&gt;&gt;任务失败 运用归纳分析能力的思考过程则是这样的： 目标=&gt;&gt;清晰地描述问题，把问题归纳成类=&gt;&gt;根据类别将大问题拆解成可以实作的小问题=&gt;&gt;做出最小规模的解决问题的方案（遇到的一般是时间精力等工作量的问题而不是不知道该怎么做的问题）=&gt;&gt;更新迭代进步=&gt;&gt;逐渐完成一开始被拆解的任务=&gt;&gt;任务成功 两个概念：1.正确的开发步骤： 开发的步骤：目标——做job-listing的网站=&gt;&gt;”用户故事“理清需求（描述和拆解问题）=&gt;&gt;做出最小可行产品,这里是crud操作=&gt;&gt;产品不断更新迭代（加上管理员与一般使用者的身份判断和前台后台的不同界面）=&gt;&gt;fontawesome美化界面，为调整工作的隐藏和公开状态而增加一个按钮以优化用户体验等=&gt;&gt;完成目标 为什么用”用户故事的方法？“ 把做产品归纳为服务不同的人。用”身为「某角色」，会做「某事」，以完成「某商业价值」“的标准衡量功能的价值，瞬间就会变得非常聚焦，所有功能都是「各角色所需要的关键功能」，把人的需求满足，我们的任务就完成了。在这里就是我要服务的就是管理员和使用者。 通过“Must have、should have、could have、nice to have”归纳出问题的重要性。做出基本的”CRUD“进行的功能，这非常重要，在这个基础上能教我如何开始，帮我抑制完美主义的狂想，实现从0到1的开端，然后在此基础上实现从1到N的发展。 怎样用？ 把想到的需求写下来 整理精简需求,归纳出角色,用V1级别的绿色圈圈圈起来。根据角色开始开发功能,这里先开发管理员功能 2.一个通用的顺利完成开发的方法(两个顺序——MVC和CRUD,CRUD之前先加路由route)： 做事不重不漏,产品可以随时迭代，代码可扩展，后续想增加什么东西不会跟前面有大的冲突。写代码的顺按照MVC的顺序，先设计Model，然后增加Controller,和view。 Model是一个承载CRUD操作和逻辑判断的载体。先增加两个字段title，description用来CRUD操作，涉及到选择的，”是还是不是“——可以用boolean值来实现。比如是否是管理员，工作是否隐藏用boolean值实现逻辑判断。 Controller的生成要放在V前面，因为有时在terminal中无法先生成view页面。 View安装bootstrap的gem，然后再文件中配置一下，一般去app/assets/stylesheets/application.scss和app/assets/javascripts/application.js这两个文件中配置。 按照CRUD的顺序，依次写各种功能的MVC代码。 迭代一次——分出前台后台，增加管理员面板以及判断,rails g controller admin::jobs。 迭代两次——往model中加入薪资上下线字段。 123validates :wage_upper_bound, presence: truevalidates :wage_lower_bound, presence: truevalidates :wage_lower_bound, numericality: &#123; greater_than: 0&#125; 迭代三次——增加隐藏/公开工作功能。 12345 class AddIsHiddenToJob &lt; ActiveRecord::Migration[5.0] def change add_column :jobs, :is_hidden, :boolean, default: true endend 迭代四次——增加fontawesome,sidebar,增加隐藏/公开工作功能按钮进行页面美化和功能的增加优化。 fontawesome 1234567def render_job_status(job) if job.is_hidden content_tag(:span, &quot;&quot;, :class =&gt; &quot;fa fa-lock&quot;) else content_tag(:span, &quot;&quot;, :class =&gt; &quot;fa fa-globe&quot;) end end sidebar 123&lt;ul class=&quot;nav nav-pills nav-stacked&quot; style=&quot;max-width: 300px; padding-top:20px;&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;%= link_to(&quot;Jobs&quot;, admin_jobs_path ) %&gt; &lt;/li&gt;&lt;/ul&gt; 增加隐藏/公开工作功能 123456789101112def publish @job = Job.find(params[:id]) @job.is_hidden = false @job.save redirect_to :back enddef hide @job = Job.find(params[:id]) @job.is_hidden = true @job.save redirect_to :back end 然后任务完成。 Reflective 今天的情绪平稳 Interpretive我们今天学到了什么? 上文所述两个概念。 今天一个重要的领悟是什么? 格式化写作可以大大增加写作效率，减少写作的时间。这篇文章从早上10点到现在16：13，修修改改花了太多时间了。虽然整理自己思绪是很重要的一件事，但这样耗不起。 Decisional 今天的工作合格，计划没有全部完成，这是因为计划订的不够实际还是自己做事拖拉？这需要调整。不吃饭工作又困又饿实在不好受。 今后要积累更多的写作模板以高效写作。","tags":[{"name":"方法总结","slug":"方法总结","permalink":"https://peckliu2017.github.io/tags/方法总结/"}]},{"title":"2017.4.7 ORID","date":"2017-04-07T14:08:02.000Z","path":"2017/04/07/2017-4-7-ORID/","text":"Objective关于今天的知识, 你记得什么? hexo的个人博客搭建，见证了一些大神的作品，心中极为震撼。熟悉了一些技术细节，将写在前端学习里。 完成了什么? hexo的搜索功能，disqus留言板功能，cotegory,tags功能，markdown发布第一篇个人博客。 Reflective你要如何形容今天的情绪 渐渐进入一种痴迷状态，痴迷，就是要被酷的东西吸引。被打断很暴躁，这需要注意。 今天的高峰是什么? 当我看到大神亮瞎眼的github账号，所开发的精美的博客模板，淡定清秀的笑容，充满美感的摄影，清新的文笔，还有对音乐游戏的高度审美，羞涩谦虚的态度，不禁痴迷，震撼。 今天的低点是什么? disqus装不上时深深焦虑。 Interpretive我们今天学到了什么? 心态和解决问题速度的认识。 自己的心态仍需要锻炼，遇到需要了解的英文文档，要耐心把它看完。 需要我搜索的问题，一定要注意用英文关键字Google。自己琢磨接近3小时没有成果，Google瞬间找到了方向。 今天一个重要的领悟是什么? 编程能力说到底是理解认知能力的进步，无论是编码能力还是学习搜索能力。 以后一定要学好英文，这样可以直接看原文技术文档。中文二手翻译资料好多不详细，而且因为软件版本变化，不看最新官方说明文档使用相关软件和服务简直是盲人摸象。零零碎碎地看中英文教程相当于随机抽牌比牌面，有英文技术文档阅读能力则相当于拥有透视眼直接看穿所有牌面。 Decisional我们会如何用一句话形容今天的工作 直到被node.js搞得痛不欲生，才知道Github Pages免费博客可以用ruby做，直到自己“终日而思不如须臾之所学”才知道Google，以后思考问题一定要想到离自己最近的工具。一定要学好ruby，然后用ruby做一个致敬前辈的一模一样的网站。 有哪些工作需要明天继续努力? 继续熟悉job-listing的开发思路，把代码做一遍。然后看全栈营其它学长学姐的作品，学习3个相关功能。然后带着问题参加晚上的meetup。","tags":[{"name":"ORID","slug":"ORID","permalink":"https://peckliu2017.github.io/tags/ORID/"}]},{"title":"2017.4.6 ORID","date":"2017-04-07T05:44:01.000Z","path":"2017/04/07/2017-4-6-ORID/","text":"Objective关于今天的课程, 你记得什么? job-listing的开发。 完成了什么? 自己完成了一部分功能，体会到了迁移思考的过程，这跟直接抄答案是完全不一样的。 Reflective你要如何形容今天的情绪 总体较好。能够控制自己的情绪。 今天的高峰是什么? 线上meetup的分享。 今天的低点是什么? 怕写代码失败。看到少数几个人已经提交了作业，也想要提前交作业，这种心态不是很好。 Interpretive我们今天学到了什么? 进一步记录自己的时间花费 今天一个重要的领悟是什么? 有问题可以自己琢磨，但也可以先Google。要注意哪种方法更高效。 Decisional我们会如何用一句话形容今天的工作 还可以吧，保证了时间上的投入。 有哪些工作需要明天继续努力? 继续熟悉job-listing的开发思路。 开始弄自己的个人网站，先把首页弄出来。要怀着开心兴奋探索的心情去做这件事。","tags":[{"name":"ORID","slug":"ORID","permalink":"https://peckliu2017.github.io/tags/ORID/"}]},{"title":"Hello World","date":"2017-04-01T19:37:02.000Z","path":"2017/04/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]