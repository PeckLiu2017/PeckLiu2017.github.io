[{"title":"Ruby元编程笔记—— 方法","date":"2017-09-19T11:10:04.000Z","path":"2017/09/19/Ruby元编程笔记——-方法/","text":"在理解了方法查找的基础上，可以在运行时创建方法、插入方法调用、把调用转发给其他对象，甚至调用一个不存在的方法。 对每一次方法调用，静态语言的编译器都会检查接收对象是否有一个匹配的方法，称之为静态类型检查（static type checking）。动态语言——比如Python和Ruby，没有静态类型检查（static type checking），这是进行元编程的基础。 元编程的好处：本章的元编程技术可以使代码更加简洁，也有利于代码更新和维护。 先来看一段代码，通过重构的过程，逐步了解元编程怎样发挥作用。 这是一个连接数据库并查询相关信息的data_source类。为节省时间，可直接跳到第三步重构步骤，需要回来看再跳回来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class DS # attr_accessor :workstation_id def initialize &quot;...connect...&quot; end def get_cpu_info(workstation_id) cpu_info = if workstation_id == 1 &quot;intel core i7&quot; else workstation_id == 2 &quot;apple AM 11&quot; end end def get_cpu_price(workstation_id) cpu_price = if workstation_id == 1 2500 else workstation_id == 2 2000 end end def get_mouse_info(workstation_id) mouse_info = if workstation_id == 1 &quot;雷蛇&quot; else workstation_id == 2 &quot;牧马人&quot; end end def get_mouse_price(workstation_id) mouse_price = if workstation_id == 1 300 else workstation_id == 2 500 end end def get_keyboard_info(workstation_id) keyboard_info = if workstation_id == 1 &quot;机械键盘&quot; else workstation_id == 2 &quot;普通键盘&quot; end end def get_keyboard_price(workstation_id) keyboard_price = if workstation_id == 1 500 else workstation_id == 2 90 end endend 这是一个computer类。 12345678910111213141516171819202122232425262728293031323334require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def mouse info = @data_source.get_mouse_info(@id) price = @data_source.get_mouse_price(@id) result = &quot;Mouse: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def cpu info = @data_source.get_cpu_info(@id) price = @data_source.get_cpu_price(@id) result = &quot;Cpu: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def keyboard info = @data_source.get_keyboard_info(@id) price = @data_source.get_keyboard_price(@id) result = &quot;Keyboard: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 endendcomputer = Computer.new(1,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 现在我们使用元编程的技术对Computer类增加动态派发，进行第一次重构： 12345678910111213141516171819202122232425262728293031require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def mouse component :mouse end def cpu component :cpu end def keyboard component :keyboard end def component(name) info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 首先把重复的代码提取到一个方法中，然后把mouse，cpu，keyboard方法代理到component方法上。component方法会接着调用DS类的get_XXX_info和get_XXX_price方法。然后执行相关操作。 现在重复代码被消灭了很多，但仍然可以进一步精简。 什么是动态派发？ 在代码运行的最后一刻再决定调用哪个方法，被称为动态派发。比如@datasource.send “get#{name}_info”, @id的使用。 现在我们使用define_method方法来动态创建方法，以进行第二次重构： 12345678910111213141516171819202122232425require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def self.define_component(name) define_method(name) do info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end end define_component :mouse # 调用第一次创建mouse方法 define_component :cpu # 调用第二次创建cpu方法 define_component :keyboard # 调用第三次创建keyboard方法endcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard define_method可以代替def关键字定义方法，这次重构中，self.define_component(name)方法执行了三次，每一次又都调用define_method分别创建了mouse ，cpu，keyboard方法。然后执行相关操作。 这三个在运行时被定义的方法被称为动态方法。 接下来又有一个关于代码维护和拓展的问题：如果将来DS类中加入了get_display_info方法，而Computer类中并没有动态派发这个方法，能不能在不修改Computer代码的基础上，自动将get_display_info方法加入到Computer的动态派发中呢？ 用内省的方式第三次重构： 1234567891011121314151617181920212223require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source data_source.methods.grep(/^get_(.*)_info$/)&#123; Computer.define_component $1 &#125; end def self.define_component(name) define_method(name) do info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 这次重构中新加入的data_source.methods.grep(/^get_(.*)_info$/){ Computer.define_component $1 }的作用如下： 当程序执行到puts computer.mouse时，会去Computer类中去找mouse方法，在initialize中，data_source.methods.grep(/^get_(.*)_info$/)如果找到get_mouse_info方法就会用mouse作为参数传给Computer.define_component，随后Computer.define_component会创建mouse方法。 上面的三次重构用到了动态派发和动态方法的技术。接下来是运用幽灵方法和动态代理来解决代码重构的问题。 第四次重构： 1234567891011121314151617181920212223242526require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def method_missing(name) super if !@data_source.respond_to?(&quot;get_#&#123;name&#125;_info&quot;) info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def respond_to_missing?(method, include_private = false) @data_source.respond_to?(&quot;get_#&#123;method&#125;_info&quot;) || super endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboardputs computer.respond_to?(:mouse) 当程序执行到puts computer.mouse时，因为computer中没有直接定义mouse方法，所以会调用method_missing方法，如果在@data_source中找到了get_mouse_info，就会用mouse作为参数动态派发get_mouse_info和get_mouse_price执行相应程序返回相应结果。 什么叫幽灵方法？ method_missing 被称作幽灵方法，它可以动态地创建方法。 什么叫动态代理？ 一个捕获幽灵方法调用并把它们转发给另外一个对象的对象（有时也会在转发前后包装一些自己的逻辑，在这里指自己重写的method_missing方法），称为动态代理（Dynamic Proxy）。 当一个幽灵方法和一个真实方法发生名字冲突时这个问题是动态代理技术的通病，当一个幽灵方法和一个真实方法发生名字冲突时，后者会胜出。为了解决这个问题，你可以通过继承白板类和删除重名方法的方法来定义方法。继承白板类: 1class XXX &lt; BasicObject 删除重名方法: 可以使用Module#undef_method()方法，它会删除所有的（包括继承来的）方法；也可以使用Module#remove_method()方法，它只会删除接收者自己的方法，而保留继承来的方法。","tags":[{"name":"Ruby元编程笔记","slug":"Ruby元编程笔记","permalink":"https://peckliu2017.github.io/tags/Ruby元编程笔记/"}]},{"title":"Hello World","date":"2017-04-01T19:37:02.000Z","path":"2017/04/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]