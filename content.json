[{"title":"Ruby元编程笔记——代码块","date":"2017-09-20T14:59:12.000Z","path":"2017/09/20/Ruby元编程笔记——代码块/","text":"我把这章内容所讲到的内容理解为打破封装，随时随地增加或修改变量和方法的技术。 代码块作为“程序中的基本操作元素之一”，是实现下面这些操作的基础： 代码块是闭包，闭包的作用在于，让变量在指定的作用域发挥作用，不会受到作用域外变量的干扰。也在于将变量带到别人作用域。 接下来依次记录块，作用域以及打破封装共享变量的技术。 块12345def a_method(a, b) a + yield(a, b)enda_method(1, 2) &#123;|x, y| (x + y) * 3 &#125; #=&gt; 10 通常情况下，如果只有一行，代码块可以通过大括号定义，比如上面的{|x, y| (x + y) * 3 }，若有多行，可以通过def...end来定义。 在调用一个方法时才可以定义一个块。块会被直接传递给这个方法，该方法可以用yield关键字调用这个块。 通过Kernel#block_given?()方法来询问当前的方法调用是否包含块。 1234567def a_method return yield if block_given? &apos;no block&apos;enda_method # &quot;no block&quot;a_method &#123; &quot;here&apos;s a block!&quot; &#125; # &quot;here&apos;s a block!&quot; 可以运行的代码由两部分组成：代码本身和一组绑定。 从上面两个例子可以看出，代码块是闭包，它可以把变量带出原来的作用域，带入a_method中执行。代码块不能孤立地运行，它需要一个执行环境：局部变量，实例变量，self等。可运行的代码包括两部分：代码本身和一组绑定。那么代码块是如何获得一组绑定的呢？ 1234567def my_method x = &quot;Goodbye&quot; yield(&quot;cruel&quot;)endx = &quot;Hello&quot;my_method &#123;|y| &quot;#&#123;x&#125;, #&#123;y&#125; world&quot; &#125; # &quot;Hello, cruel world&quot; 创建代码块时，代码块会获得局部绑定，然后将这两者一起传给一个方法。 还可以在代码块内定义额外的绑定，但这些绑定在代码块结束时就消失了。 12345678910111213141516def just_yield return yield if block_given?endtop_level_variable = 1just_yield do top_level_variable += 1 local_to_block = 1 puts local_to_block # =&gt; 1endputs top_level_variable # =&gt; 2puts local_to_block# =&gt; block_local_vars_failure.rb:24:in `&lt;main&gt;&apos;:# undefined local variable or method `local_to_block&apos; for main:Object (NameError) 基于代码块可以获取局部绑定并一直携带它们的特性，那应该如何使用闭包呢？接下来就要理解作用域了。局部变量之所以被称为局部变量，也是因为它只在自己的作用域内有效。 作用域 作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。 作用域通过作用域门来划分。程序会在作用域门关闭前一个作用域，同时打开一个新的作用域，作用域门有三处地方： 1.类定义。 2.模块定义。 3.方法。 切换作用域下面的例子演示了在程序运行时作用域是怎样切换的，它会用Kernel#local_variables()方法来跟踪绑定的名字： 12345678910111213141516blocks/scopes.rbmodule MyModule # 作用域门：进入module v1 = 1 class MyClass # 作用域门：进入class v2 = 2 local_variables # [:v2] def my_method # 作用域门：进入def v3 = 3 local_variables end # 作用域门：离开def local_variables # [:v2] end # 作用域门：离开classend # 作用域门：离开moduleobj = MyClass.newobj.my_method # [:v3]local_variables # [:v1, :obj] 在一些语言中，比如Java和C#，有“内部作用域（innerscope）”的概念。在内部作用域中可以看到“外部作用域（outerscope）”中的变量。但Ruby中没有这种嵌套式的作用域，它的作用域之间是截然分开的：一旦进入一个新的作用域，原先的绑定就会被替换为一组新的绑定。这意味着在程序进入MyClass后，v1便“超出作用域范围”，从而就不可见了。 几种变量及其作用域： 全局变量 顶级实例变量 局部变量 123456789101112131415161718192021222324252627282930313233343536373839&gt; class A&gt; $var1 = 2 # =&gt; 全局变量&gt; @var = &quot;the top level variable&quot; # =&gt;顶级实例变量&gt; &gt; def my_method&gt; puts @var&gt; var2 = 3&gt; end&gt; &gt; def my_method1&gt; puts var2&gt; # =&gt; NameError: undefined local variable or method `var2&apos; for&gt; # # &lt;A:0x007ffc8f8bfe00&gt; 在my_method中定义的局部变量不能在my_method1中使用&gt; end&gt; end&gt;&gt; class B&gt; def my_method&gt; puts $var1&gt; end&gt; &gt; def my_method1&gt; puts @var2&gt; end &gt; end&gt;&gt; a = A.new&gt; #=&gt; #&lt;A:0x007ffd08900328&gt;&gt; a.my_method&gt; # 没有输出，要由main扮演self的角色，才能有用。而这里的self是对象a&gt; # 所以去掉classA，直接在irb中运行这段代码才可以输出@var&gt;&gt; b = B.new&gt; #=&gt; #&lt;B:0x007fb62584bb78&gt;&gt; b.my_method&gt; #=&gt; 2 # 全局变量可以在任何作用域中访问，所以即使$var1定义在A中，B的my_method方法也可以输出它&gt; b.my_method1&gt; # 没有输出&gt; &gt; 全局变量的问题在于系统的任何部分都可以修改它们。因此，你会立即发现几乎没法追踪谁把它们改成了什么。正因为如此，基本的原则是：如非必要，尽可能少使用全局变量。 你有时可以用顶级实例变量来代替全局变量，只要main对象在扮演self的角色，就可以访问一个顶级实例变量。但当其他对象成为self时，顶级实例变量就退出作用域了。 如果希望让一个变量穿越作用域，那么该怎么做呢？要解答这个问题，还是得回到块的主题上。 如何改变作用域的范围？1.扁平化作用域：1234567my_var = &quot;Success&quot;class MyClass # 你希望在这里打印my_var... def my_method # ..还有这里 endend class这个作用域门。虽然不能让my_var穿越它，但是可以把class关键字替换为某个非作用域门的东西：方法。如果能用方法替换class，就能在一个闭包中获得my_var的值，并把这个闭包传递给该方法。 所以上面的代码可以这样修改： 12345678910my_var = &quot;Success&quot;MyClass = Class.new doputs &quot;# 你希望在这里打印 my_var = #&#123;my_var&#125;&quot; define_method :my_method do puts &quot;# ..还有这里 my_var = #&#123;my_var&#125;&quot; endendmc = MyClass.newputs mc.my_method 这里用了Class.new以及define_method实现扁平作用域，从而实现了变量共享。 扁平化作用域，顾名思义就是把作用域挤压在一起，共享变量。 2.共享作用域假定你想在一组方法之间共享一个变量，但是又不希望其他方法也能访问这个变量，就可以把这些方法定义在那个变量所在的扁平作用域中，这时这个扁平作用域中也叫做共享作用域。 12345678910111213141516def define_methods shared = 0 Kernel.send :define_method, :counter do shared end Kernel.send :define_method, :inc do |x| shared += x endenddefine_methodscounter # =&gt; 0inc(4)counter # =&gt; 4 用自己的话整理了改变作用域操作代码块的操作：1.更改一个类中的实例变量1234567891011121314class MyClass def initialize @v = 1 endendobj = MyClass.new # =&gt; #&lt;MyClass:0x007f93d5852260 @v=1&gt;obj.instance_eval do self #=&gt; #&lt;MyClass:0x007f93d5852260 @v=1&gt; @v #=&gt; 1endv = 2 obj.instance_eval &#123; @v = v &#125;obj.instance_eval &#123; @v &#125; # 2 2.传递一个块到一个方法中12345def a_method(a, b) a + yield(a, b)enda_method(1, 2) &#123;|x, y| (x + y) * 3 &#125; #=&gt; 10 这里就把{|x, y| (x + y) * 3 }传递到a_method方法中，然后用yield求出程序的最终结果。 3.传递一个块的结果到一个到另一个块中123456789101112class CleanRoom def current_temperature 19 endendcr = CleanRoom.newcr.instance_eval do if current_temperature &lt; 20 puts &quot;wear jacket&quot; endend 但是instance_eval无法传递参数，要改用instance_exec，下面的例子比较了它们之间的区别 123456789101112131415161718192021222324252627282930class C def initialize @x = 1 end def my_method @x endendclass D def twisted_method @y = 2 C.new.instance_eval &#123; &quot;@x: #&#123;@x&#125;, @y: #&#123;@y&#125;&quot; &#125; endendputs D.new.twisted_method# =&gt; @x: 1, @y:# 把instance_eval换成instance_execclass D def twisted_method @y = 2 C.new.instance_exec(@y) &#123; |y| &quot;@x: #&#123;@x&#125;, @y: #&#123;y&#125;&quot; &#125; endendputs D.new.twisted_method# =&gt; @x: 1, @y: 2 剖析代码块的底层从底层看，使用代码块分为两步，一是将代码块打包备用，二是是执行被打包的代码。这些打包备用的东西就是可调用对象： 1.块 2.使用proc。proc基本上就是一个由块转换成的对象。 3.使用lambda。它是proc的近亲。 4.使用方法。 Proc对象尽管Ruby中绝大多数东西都是对象，但是块不是。为什么要关心这个呢？设想希望存储[一个块供以后执行]，这时，你需要一个对象才能做到。Bill说道，“为了解决这个问题，Ruby在标准库中提供了名为Proc的类。”一个Proc就是一个转换成对象的块。 123inc = Proc.new &#123;|x| x + 1 &#125;# 更多...inc.call(2) #=&gt;3 这种先打包代码，以后调用的技术称为延迟执行（Deferred Evaluation）。 123dec = lambda &#123;|x| x - 1 &#125;dec.class #=&gt;Procdec.call(2) #=&gt;1 &amp;操作符&amp;操作符能把代码块传递给另一个方法或者代码块。 1234567891011# 这里&#123; |x, y| x * y &#125;就被当成&amp;operation参数传递给do_math方法，随后再被传递给math方法def math(a, b) yield(a, b)enddef do_math(a, b, &amp;operation) math(a, b, &amp;operation)end# puts do_math(2, 3)&#123; |x, y| x * y &#125;puts do_math(2, 3) #=&gt; wrong &amp;操作符会把proc对象my_proc转换为块，再把这个块传给这个方法 123456def my_method(greeting) puts &quot;#&#123;greeting&#125;, #&#123;yield&#125;!&quot;endmy_proc = proc &#123; &quot;Bill&quot; &#125;my_method(&quot;Hello&quot;, &amp;my_proc) Proc和lambda的区别:1.对return的处理不同。12345678910def double(callable_object) callable_object.call * 2endl = lambda &#123; return 10 &#125;double(l) # 20p = Proc.new &#123; return 10 &#125;# 这会失败，并产生一个LocalJumpError错误:# double(p) 2.对参数检查的容忍度不同。1234p = Proc.new&#123; |a, b| [a, b] &#125;p.arity #=&gt; 2p.call(1,2,3) #=&gt; [1, 2]p.call(1) #=&gt; [1, nil] proc根据实际参数的数量自动调整输出结果。再来看lambda 1234ld = lambda&#123; |a, b| [a, b] &#125;ld.arity #=&gt; 2ld.call(1,2,3) #=&gt; ArgumentError: wrong number of arguments (given 3, expected 2)ld.call(1) #=&gt; ArgumentError: wrong number of arguments (given 1, expected 2) 如果参数个数不恰好是两个，就会报错。 方法也是一个可调用对象：1234567891011121314blocks/methods.rbclass MyClass def initialize(value) @x = value end def my_method @x endendobject = MyClass.new(1)m = object.method :my_methodm.call =&gt; # 1 这章知识的运用：开发一个DSL语言，进行几次重构，使代码质量不断进阶： 1.作用域共享 2.变量不要胡乱地散落在顶级作用域里 3.把事件触发条件从代码块转换成proc 4.消灭全局变量，使用共享作用域 5.增加洁净室","tags":[{"name":"Ruby元编程笔记","slug":"Ruby元编程笔记","permalink":"https://peckliu2017.github.io/tags/Ruby元编程笔记/"}]},{"title":"Ruby元编程笔记—— 方法","date":"2017-09-19T11:10:04.000Z","path":"2017/09/19/Ruby元编程笔记——-方法/","text":"在理解了方法查找的基础上，可以在运行时创建方法、插入方法调用、把调用转发给其他对象，甚至调用一个不存在的方法。接下来的元编程技术讲解了如何实现这些操作。 本章的主要内容：通过元编程技术使代码更加简洁，更有利于扩展和维护。 先来看一段代码，通过重构的过程，逐步了解元编程怎样发挥作用。 这是一个连接数据库并查询相关信息的data_source类。为节省时间，可直接跳到第三步重构步骤，需要时再跳回来看。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class DS # attr_accessor :workstation_id def initialize &quot;...connect...&quot; end def get_cpu_info(workstation_id) cpu_info = if workstation_id == 1 &quot;intel core i7&quot; else workstation_id == 2 &quot;apple AM 11&quot; end end def get_cpu_price(workstation_id) cpu_price = if workstation_id == 1 2500 else workstation_id == 2 2000 end end def get_mouse_info(workstation_id) mouse_info = if workstation_id == 1 &quot;雷蛇&quot; else workstation_id == 2 &quot;牧马人&quot; end end def get_mouse_price(workstation_id) mouse_price = if workstation_id == 1 300 else workstation_id == 2 500 end end def get_keyboard_info(workstation_id) keyboard_info = if workstation_id == 1 &quot;机械键盘&quot; else workstation_id == 2 &quot;普通键盘&quot; end end def get_keyboard_price(workstation_id) keyboard_price = if workstation_id == 1 500 else workstation_id == 2 90 end endend 这是一个computer类。 12345678910111213141516171819202122232425262728293031323334require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def mouse info = @data_source.get_mouse_info(@id) price = @data_source.get_mouse_price(@id) result = &quot;Mouse: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def cpu info = @data_source.get_cpu_info(@id) price = @data_source.get_cpu_price(@id) result = &quot;Cpu: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def keyboard info = @data_source.get_keyboard_info(@id) price = @data_source.get_keyboard_price(@id) result = &quot;Keyboard: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 endendcomputer = Computer.new(1,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 现在我们使用元编程的技术对Computer类增加动态派发，进行第一次重构： 12345678910111213141516171819202122232425262728293031require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def mouse component :mouse end def cpu component :cpu end def keyboard component :keyboard end def component(name) info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 首先把重复的代码提取到一个方法中，然后把mouse，cpu，keyboard方法代理到component方法上。component方法会接着调用DS类的get_XXX_info和get_XXX_price方法。然后执行相关操作。 现在重复代码被消灭了很多，但仍然可以进一步精简。 什么是动态派发？ 在代码运行的最后一刻再决定调用哪个方法，被称为动态派发。比如@datasource.send “get#{name}_info”, @id的使用。 现在我们使用define_method方法来动态创建方法，以进行第二次重构： 12345678910111213141516171819202122232425require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def self.define_component(name) define_method(name) do info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end end define_component :mouse # 调用第一次创建mouse方法 define_component :cpu # 调用第二次创建cpu方法 define_component :keyboard # 调用第三次创建keyboard方法endcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard define_method可以代替def关键字定义方法，这次重构中，self.define_component(name)方法执行了三次，每一次又都调用define_method分别创建了mouse ，cpu，keyboard方法。然后执行相关操作。 这三个在运行时被定义的方法被称为动态方法。 接下来又有一个关于代码维护和拓展的问题：如果将来DS类中加入了get_display_info方法，而Computer类中并没有动态派发这个方法，能不能在不修改Computer代码的基础上，自动将get_display_info方法加入到Computer的动态派发中呢？ 用内省的方式第三次重构： 1234567891011121314151617181920212223require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source data_source.methods.grep(/^get_(.*)_info$/)&#123; Computer.define_component $1 &#125; end def self.define_component(name) define_method(name) do info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 这次重构中新加入的data_source.methods.grep(/^get_(.*)_info$/){ Computer.define_component $1 }的作用如下： 当程序执行到puts computer.mouse时，会去Computer类中去找mouse方法，在initialize中，data_source.methods.grep(/^get_(.*)_info$/)如果找到get_mouse_info方法就会用mouse作为参数传给Computer.define_component，随后Computer.define_component会创建mouse方法。 上面的三次重构用到了动态派发和动态方法的技术。接下来是运用幽灵方法和动态代理来解决代码重构的问题。 第四次重构： 1234567891011121314151617181920212223242526require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def method_missing(name) super if !@data_source.respond_to?(&quot;get_#&#123;name&#125;_info&quot;) info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def respond_to_missing?(method, include_private = false) @data_source.respond_to?(&quot;get_#&#123;method&#125;_info&quot;) || super endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboardputs computer.respond_to?(:mouse) 当程序执行到puts computer.mouse时，因为computer中没有直接定义mouse方法，所以会调用method_missing方法，如果在@data_source中找到了get_mouse_info，就会用mouse作为参数动态派发get_mouse_info和get_mouse_price执行相应程序返回相应结果。 什么叫幽灵方法？ method_missing 被称作幽灵方法，它可以动态地创建方法。 什么叫动态代理？ 一个捕获幽灵方法调用并把它们转发给另外一个对象的对象（有时也会在转发前后包装一些自己的逻辑，在这里指自己重写的method_missing方法），称为动态代理（Dynamic Proxy）。 当一个幽灵方法和一个真实方法发生名字冲突时这个问题是动态代理技术的通病，当一个幽灵方法和一个真实方法发生名字冲突时，后者会胜出。为了解决这个问题，你可以通过继承白板类和删除重名方法的方法来定义方法。继承白板类: 1class XXX &lt; BasicObject 删除重名方法: 可以使用Module#undef_method()方法，它会删除所有的（包括继承来的）方法；也可以使用Module#remove_method()方法，它只会删除接收者自己的方法，而保留继承来的方法。","tags":[{"name":"Ruby元编程笔记","slug":"Ruby元编程笔记","permalink":"https://peckliu2017.github.io/tags/Ruby元编程笔记/"}]},{"title":"Hello World","date":"2017-04-01T19:37:02.000Z","path":"2017/04/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]