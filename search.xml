<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[条件渲染]]></title>
    <url>%2F2017%2F12%2F15%2F%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[分析条件渲染在 react 中涉及到状态管理。 用方程的方式构建选择组件：目标根据登陆状态显示提示。 步骤分析： 在 &lt;Greeting isLoggedIn={false} /&gt; 中传入 isLoggedIn 参数 用 Greeting() 生成 html 内容 ReactDOM.render() 函数渲染提交 123456789101112131415161718192021222324252627282930313233&lt;!-- 用方程而非类的形式构建组件 --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 引入 react CDN文件和 Babel 编译器 --&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 构建容器 --&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;!-- Babel 代码 --&gt; &lt;script type=&quot;text/babel&quot;&gt; /* 选择组件 */ function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;; &#125; return &lt;h1&gt;Please sign up.&lt;/h1&gt;; &#125; /* 渲染 */ ReactDOM.render( // Try changing to isLoggedIn=&#123;true&#125;: &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 用类的方式构建选择组件：目标通过传入的性别，显示男士组或女士组的多个图片。 步骤分析： 在 &lt;RenderPicture gender={&#39;woman&#39;} /&gt; 中传入性别 用 RenderPicture 类的 selectPicture() 生成图片地址数组 在 RenderPicture 类的 render() 函数中遍历图片并渲染 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 引入 react CDN文件和 Babel 编译器 --&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 构建容器 --&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;!-- Babel 代码 --&gt; &lt;script type=&quot;text/babel&quot;&gt; /* 构建组件 */ class RenderPicture extends React.Component &#123; state = &#123; gender: this.props.gender, &#125;; // 通过函数来生成图片地址数组 selectPicture()&#123; if (this.state.gender === &apos;woman&apos;) &#123; return [ &apos;images/img_avatar4.png&apos;, &apos;images/img_avatar5.png&apos;, &apos;images/img_avatar6.png&apos; ]; &#125; else &#123; return [ &apos;images/img_avatar1.png&apos;, &apos;images/img_avatar2.png&apos;, &apos;images/img_avatar3.png&apos; ]; &#125; &#125;; // 将储存多个图片地址的数组放在类中 // ReactDOM.render 中输入性别选项 // return 函数里至少有一个 html 标签容器 render() &#123; return ( &lt;div&gt; &#123; this.selectPicture().map((img)=&gt; ( &lt;img key=&#123;img&#125; src=&#123;img&#125; style=&#123;&#123; width: 128&#125;&#125; /&gt; )) &#125; &lt;/div&gt; ) &#125; &#125;; /* 将组件的渲染结果放入容器 */ ReactDOM.render( &lt;RenderPicture gender=&#123;&apos;woman&apos;&#125; /&gt;, document.getElementById(&apos;example&apos;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 其他示例与运算符 &amp;&amp; 、三目运算符、阻止组件渲染以及 prevState 的应用详见React 条件渲染。]]></content>
      <categories>
        <category>React 学习笔记</category>
      </categories>
      <tags>
        <tag>React 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 React 写 Hello World]]></title>
    <url>%2F2017%2F12%2F15%2F%E7%94%A8React%E5%86%99Hello%20World%2F</url>
    <content type="text"><![CDATA[思路使用一个新框架首先要建立相应开发环境，引入框架的源文件，然后用框架来写代码，最后把这些代码组织起来。 代码123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 引入 react 的CDN文件和 Babel 编译器 --&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 构建容器 --&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; /* 构建组件 */ class MyTitle extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello World&lt;/h1&gt;; &#125; &#125;; /* 将组件的渲染结果放入容器 */ ReactDOM.render( &lt;MyTitle/&gt;, document.getElementById(&apos;example&apos;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 其他方法还有其它方法，比如构建管道创建新应用，或者增加react到原有应用，具体详见React Installation。]]></content>
      <categories>
        <category>React 学习笔记</category>
      </categories>
      <tags>
        <tag>React 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计一个有 getMin（求最小值）功能的栈]]></title>
    <url>%2F2017%2F09%2F24%2F%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89-getMin%EF%BC%88%E6%B1%82%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%89%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[设计一个有 getMin（求最小值）功能的栈 要求： 1.pop、push、getMin操作的时间复杂度都是O(1)。 2.设计的栈类型可以使用现成的栈结构。 分析：基本上就是用现成的栈结构封装一下设计一个新的栈类型。 解法： 1.先设计一个栈结构：​ 123456789101112131415161718192021class Stack def initialize @stack = [] end def push(value) @stack &lt;&lt; value end def pop @stack.pop end def peek @stack.last end def empty? @stack.empty? endend 2.设计一个新的栈类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 题目要求：设计一个有 getMin（求最小值）功能的栈require_relative &apos;stack&apos;class MyStack1 # @stackData用来存储所有压入的值 # 同时 # 如果@stackMin为空 # 就压入跟@stackData一样的第一个值到栈顶 # 否则，将压入@stackData的值与栈顶的值比较 # 如果小于等于原来栈顶的值就压入，反之相反。 # 所以这个@stackMin的值从栈顶到栈底逐步变小 # 每次压入弹出的都是它的最小值 def initialize @stackData = Stack.new @stackMin = Stack.new end # 如果@stackMin为空 # 就把新数压入@stackMin之中 # 如果@stackMin不为空 # 但newNum小于@stackMin栈顶的值 # 就把newNum作为最小值放在@stackMin栈顶 # 同时把值压入@stackData栈顶 def push(newNum) if @stackMin.empty? @stackMin.push(newNum) elsif newNum &lt;= self.get_min @stackMin.push(newNum) end @stackData.push(newNum) end # 如果@stackMin为空 # 表示最小的值都没有 # 所以@stackData也为空 # 没有数据可以弹出 # 就抛出异常 # 否则记录@stackData中弹出的数字 # 如果@stackData中弹出的数字等于当前栈MyStack1实例的最小值也就是@stackMin栈顶的值 # 就同时弹出@stackMin栈顶的值 # 最后返回被从@stackData中弹出的值 def pop if @stackMin.empty? raise &apos;Your stack is empty&apos; end value = @stackData.pop if value == self.get_min @stackMin.pop end value end # 如果@stackMin为空 # 表示最小的值都没有 # 所以@stackData也为空 # 没有数据可以弹出 # 就抛出异常 # 否则返回它的位于栈顶的最小值 def get_min if @stackMin.empty? raise &apos;Your stack is empty&apos; end @stackMin.peek endendstack1 = MyStack1.newstack1.push(3); # 先把3加入栈中puts stack1.get_min # 得到最小值应该是3stack1.push(4); # 再把4加入栈中puts stack1.get_min # 3 &lt; 4,得到最小值还应该是3stack1.push(1); # 再把1加入栈中puts stack1.get_min # 1 &lt; 3,得到最小值应该是1puts stack1.pop # 将栈顶的1弹出puts stack1.get_min # 剩下的最小值应该是3]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby元编程笔记——编写代码的代码]]></title>
    <url>%2F2017%2F09%2F22%2FRuby%E5%85%83%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[任务：写一个类宏这个类宏与 attr_accessor 类似，名字叫 attr_checked 方法，它有如下特征： 它会创建经过检验的属性 接受属性名和代码块，代码块用来校验，如果对一个属性赋值，而代码块没有返回true，就会抛出异常。 attr_checked并不在每个类中都可用，因为它的初衷并不是把标准库搞的乱七八糟，只有当一个类包含CheckedAttributes模块时才能使用这个方法。 开发步骤： 使用 eval() 编写一个名为 add_checked_attribute() 的内核方法，为类添加一个最简单的经过校验的属性，比如说 age 。 这里用 eval 方法（背景知识2，3，4）是为了快速通过测试。 123456789101112131415161718192021222324252627282930313233343536373839404142require &apos;test/unit&apos;class Person; endclass TestCheckedAttribute &lt; Test::Unit::TestCase def setup add_checked_attribute(Person, :age) @bob = Person.new end def test_accepts_valid_values @bob.age = 20 assert_equal 20, @bob.age end def test_refuses_nil_values assert_raises RuntimeError, &apos;Invalid attribute&apos; do @bob.age = nil end end def test_refuses_false_values assert_raises RuntimeError, &apos;Invalid attribute&apos; do @bob.age = false end endenddef add_checked_attribute(klass, attribute) eval &quot; class #&#123;klass&#125; def #&#123;attribute&#125;=(value) raise &apos;Invalid attribute&apos; unless value @#&#123;attribute&#125; = value end def #&#123;attribute&#125;() @#&#123;attribute&#125; end end &quot;end 这里的 add_checked_attribute 方法为什么要仿照 attr_accessor 的创建的读写拟态方法呢？也许因为方法的核心内容就是读写吧。在明确了读写对象的基础上才有了比较等其它操作。所以第一步的核心是先开发出读写方法。 重构 add_checked_attribute() 方法，去掉 eval() 。 因为 eval 的缺点（背景知识3），接下来去掉 eval() 。 不用 eval() 方法，就无法使用代码字符串，继续使用 class 关键字，因为 class 不接受变量作为类名，#{klass}和的值无法动态传入。此时，可以用 class_eval 方法进入类的作用域。 同时在定义方法时也不能用 def 了，因为只有在运行时才知道方法的名字。这里可以用defind_method 来动态定义方法。至于操作实例变量，可以用 instance_variable_get 和 instance_variable_set 方法。 1234567891011121314151617181920212223242526272829303132333435363738require &apos;test/unit&apos;class Person; endclass TestCheckedAttribute &lt; Test::Unit::TestCase def setup add_checked_attribute(Person, :age) @bob = Person.new end def test_accepts_valid_values @bob.age = 20 assert_equal 20, @bob.age end def test_refuses_nil_values assert_raises RuntimeError, &apos;Invalid attribute&apos; do @bob.age = nil end end def test_refuses_false_values assert_raises RuntimeError, &apos;Invalid attribute&apos; do @bob.age = false end endenddef add_checked_attribute(klass, attribute) klass.class_eval do define_method &quot;#&#123;attribute&#125;=&quot; do |value| raise &apos;Invalid attribute&apos; unless value instance_variable_set(&quot;@#&#123;attribute&#125;&quot;, value) end define_method attribute do instance_variable_get &quot;@#&#123;attribute&#125;&quot; end endend 通过块来校验属性。 目前代码只能简单地对赋值 nil 或 false 的情况抛出异常，没有代码块验证的灵活。这里通过 &amp;validation 来做代码块验证。 1234567891011121314151617181920212223242526272829303132require &apos;test/unit&apos;class Person; endclass TestCheckedAttribute &lt; Test::Unit::TestCase def setup add_checked_attribute(Person, :age) &#123;|v| v &gt;= 18 &#125; @bob = Person.new end def test_accepts_valid_values @bob.age = 20 assert_equal 20, @bob.age end def test_refuses_invalid_values assert_raises RuntimeError, &apos;Invalid attribute&apos; do @bob.age = 17 end endenddef add_checked_attribute(clazz, attribute, &amp;validation) clazz.class_eval do define_method &quot;#&#123;attribute&#125;=&quot; do |value| raise &apos;Invalid attribute&apos; unless validation.call(value) instance_variable_set(&quot;@#&#123;attribute&#125;&quot;, value) end define_method attribute do instance_variable_get &quot;@#&#123;attribute&#125;&quot; end endend 将 add_checked_attribute() 改名为 attr_checked 的类宏，它对所有类可用。 这意味着应该定义一个可以在类定义中使用的方法，另外新方法不能像 add_checked_attribute() 一样接受类名作为参数，应该只接受属性名作为参数。 1234567891011121314151617181920212223242526272829303132333435require &apos;test/unit&apos;class Person attr_checked: age do |v| v &gt;= 18 endendclass TestCheckedAttribute &lt; Test::Unit::TestCase def setup @bob = Person.new end def test_accepts_valid_values @bob.age = 20 assert_equal 20, @bob.age end def test_refuses_invalid_values assert_raises RuntimeError, &apos;Invalid attribute&apos; do @bob.age = 17 end endendclass Class def attr_checked(attribute, &amp;validation) define_method &quot;#&#123;attribute&#125;=&quot; do |value| raise &apos;Invalid attribute&apos; unless validation.call(value) instance_variable_set(&quot;@#&#123;attribute&#125;&quot;, value) end define_method attribute do instance_variable_get &quot;@#&#123;attribute&#125;&quot; end endend 写一个模块，通过钩子方法（背景知识5）为指定的类添加 attr_checked 方法。 12345678910111213141516171819202122232425262728293031323334353637module CheckedAttributes def self.included(base) base.extend ClassMethods end module ClassMethods def attr_checked(attribute, &amp;validation) define_method &quot;#&#123;attribute&#125;=&quot; do |value| raise &apos;Invalid attribute&apos; unless validation.call(value) instance_variable_set(&quot;@#&#123;attribute&#125;&quot;, value) end define_method attribute do instance_variable_get &quot;@#&#123;attribute&#125;&quot; end end endendrequire &apos;test/unit&apos;class Person include CheckedAttributes attr_checked :age do |v| v &gt;= 18 endendclass TestCheckedAttributes &lt; Test::Unit::TestCase def setup @bob = Person.new end def test_accepts_valid_values @bob.age = 18 assert_equal 18, @bob.age endend 最后的结果是，公用验证代码放在 CheckedAttributes 模块中，类宏 attr_checked 验证条件在类中使用，测试液运行正常。代码结构干净利索。 背景知识补充：1.绑定对象Binding 就是一个用对象表示的完整作用域。可以通过 Binding 对象和来捕获并带走当前作用域，然后使用 eval 来计算结果，实现类似于闭包的操作。 Binding.pry会在当前绑定上打开一个Ruby解释器。 1234567891011121314151617class MyClass def my_method @x = 1 binding endendb = MyClass.new.my_methodputs eval &quot;@x&quot;, bclass AnotherClass def my_method eval &apos;self&apos;, TOPLEVEL_BINDING endendputs AnotherClass.new.my_method #=&gt; main 2.eval 的用处eval 方法自带共享作用域（和变量）的功能，能够自动衔接目标类的上下文。 从外部传入一个任意的代码字符串给 eval 方法，这样就可以创建一个简单的Ruby解释器。很多Ruby解释器都使用了 eval 方法。 3.eval 的麻烦1.不支持编辑器的功能特性，比如语法高亮和自动完成。 2.难以阅读和修改 3.Ruby执行字符串前不会进行语法检查 4.安全性不好——有可能会被代码注入 4.防止代码注入：1.限制 eval 方法只执行自己写的代码字符串。 2.禁用 eval 方法。 3.识别污染对象和设置安全级别。 5.钩子方法Ruby 提供的钩子方法种类繁多，覆盖了对象模型中绝大多数事件。当中这些事件发生（如被包含，扩展，方法增加删除等），就会触发它们。 通过覆写钩子方法如 Module#included() 方法，使得当一个模块被包含时执行额外的代码。它跟环绕别名所起到的作用有点像。 就算不覆写，也可以借助环绕别名把普通方法变成钩子方法。 尾声用平常心对待代码，它应该简洁而清晰，而不是晦涩难懂。 要有智慧忘掉所学的东西，根本没有什么元编程，只有编程而已。]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby元编程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby元编程笔记——类定义]]></title>
    <url>%2F2017%2F09%2F22%2FRuby%E5%85%83%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[本章内容理解：讲了Ruby对象模型，并且介绍了几种依赖于此模型的技术。 在Java和C#等语言中，直到你创建了该类的一个对象，然后调用对象的方法才会有实际的工作。 在Ruby中，类的定义有所不同。当使用class关键字时，并非是在指定对象未来的行为方式，相反，实际上是在运行代码。 Ruby对象模型介绍以及七条规则：1.只有一种对象——要么是普通对象，要么是模块。 类就是对象，是class类的一个实例。类也是一个增强的模块，比模块多了new、allocate、superclass三个方法。 普通对象不可以使用new方法再建立一个实例，模块也是。 2.只有一种方法——它存在于一个模块中，通常是一个类中。 无论是类或模块的实例方法，类方法，都存在于类或模块中。单件方法比较特殊，但也存在于单件类中。 3.只有一种模块——可以是一个普通模块、一个类或者单件类 模块可以是普通模块，可以是一个类，即增强的模块。同时一个普通的模块无法被继承。 12345678910module M M = 1endmodule D &lt; M D = 1endSyntaxError: (irb):15: syntax error, unexpected &apos;&lt;&apos; module D &lt; M# 一个普通的模块无法被继承。 4.每个对象都有自己”真正的类”，要么是一个普通类，要么是一个单件类。 前面好理解，至于”要么是一个单件类”这句话，可以通过这个例子理解一下： instance_eval方法把当前类改成了接收者s1的单件类。只有s1自己一个对象可以使用。 1234567s1, s2 = &quot;abc&quot;, &quot;def&quot;s1.instance_eval do def swoosh!; reverse; endends1.swoosh! #=&gt; &quot;cba&quot;s2.respond_to?(:swoosh!) #=&gt; false 5.除了BasicObject，任何类只有一条向上的、直到BasicObject的祖先链。 6.一个(普通)对象(区别于类这种对象)的单件类的超类是这个对象的类，一个类的单件类的超类是这个类的超类的单件类。 1234567891011121314151617class C class &lt;&lt; self def a_class_method &apos;C#a_class_method()&apos; end endendclass D &lt; C; endobj = D.new# 一个(普通)对象的单件类的超类是这个对象的类puts obj.singleton_class.superclass #=&gt; D# 一个类的单件类的超类是这个类的超类的单件类puts C.singleton_class.superclass #=&gt; #&lt;Class:Object&gt;puts C.superclass.singleton_class #=&gt; #&lt;Class:Object&gt; 7.调用一个方法时，Ruby先向右迈一步进入接受者真正的类，然后向上进入祖先链。这就是Ruby查找方法的方式。 如果它有单件类(规则4)，查找会从单件类开始。 为什么Ruby要以这种方式来组织对象模型？——这样就能在子类中调用父类的类方法。 12345678910class C class &lt;&lt; self # 这行代码表示开始为C定义类方法 def a_class_method &apos;C#a_class_method()&apos; end endendclass D &lt; C; endputs D.a_class_method #=&gt; C#a_class_method() #=&gt;在子类D中调用父类C的类方法。 依赖Ruby对象模型而来的技术概念：1.在不知道类名的情况下打开一个类：12345678910def add_method_to(a_class) a_class.class_eval do def m; &apos;Hello!&apos;; end endendadd_method_to String&quot;abc&quot;.m # &quot;Hello!&quot; 这里给String类增加了一个m方法。 class_eval和class的区别：class_eval使用扁平作用域，当前的绑定依然可见。 class则打开一个新的作用域，当前的绑定不可见。 class_eval和instance_eval的区别：一般用instance_eval方法打开非类的对象，用class_eval方法打开类定义。 当前类 不管Ruby程序处于哪个位置，总存在一个当前对象：self。同样，也总有一个当前类或当前模块的存在，定义一个方法时，那个方法将成为当前类的一个实例方法。 2.类实例变量和类变量类实例变量是Class类的实例——即继承Class的一般类的实例变量。一般类相对于Class类来说也就是个普通对象。它定义于一般类充当self的时刻，所以只能被它本身的类访问，不能被它的实例或者子类访问。 12345678910111213141516171819202122232425262728293031323334353637class C @@v1 = 1 # 类变量以@@开头 @v2 = 2 # 这是类实例变量 def my_method1; puts @@v1 end def my_method2; puts @v2 endendclass D &lt; C def my_method1; puts @@v1 end def my_method2; puts @v2 endendobj1 = C.newobj1.my_method1 #=&gt; 1obj1.my_method2 #=&gt; nil # 类实例变量不能被它的实例或者子类访问obj2 = D.newobj2.my_method1 #=&gt; 1obj2.my_method2 #=&gt; nil # 类实例变量不能被它的实例或者子类访问obj1.my_method1 #=&gt; 3# @@v1定义于main的上下文，属于main的类object# 所以也属于object所有的后代# 所以在C中定义的@@v1因为D#my_method1被改为3# 也因为这个特性，类变量可以在别处被修改，使用它的情况很少，使用类实例变量较多。 3.类宏类宏可以为任何ruby对象创建属性。 在给对象创造属性的时候用Module#attr_ accessor()，给类创造属性时用单件方法。 属性实际上只是一对方法，如果在单件类中定义了这些方法，那么他实际上会成为类方法。 Ruby对象并没有属性。如果希望有一些像属性的东西，就得定义两个拟态方法：一个读方法和一个写方法 1234567891011121314# class_definitions/attr.rbclass MyClass def my_attribute=(value) @my_attribute = value end def my_attribute @my_attribute endendobj = MyClass.newobj.my_attribute = &apos;x&apos;obj.my_attribute # &quot;x&quot; 写这样的方法（也叫访问器）很快就让人感到枯燥。可以通过Module#attr_ accessor()则可以生成读写方法： 123class MyClass attr_accessor :my_attributeend 为普通Ruby对象创建属性： 1234567class MyClass attr_accessor :bendobj = MyClass.newobj.a = 2puts obj.a #=&gt; 2 为类创建属性 12345678class MyClass; endclass Class attr_accessor :aendMyClass.b = 42puts MyClass.b #=&gt; 42 但这样做会让所有继承Class类的类都拥有这个属性。 123# 接上段代码MyClass1.b = 42puts MyClass1.b #=&gt; 42 所以考虑下一种做法： 将类属性创建在该类的单件类中 123456789101112class MyClass class &lt;&lt; self attr_accessor :c endendMyClass.c = &apos;It works!&apos;puts MyClass.c #=&gt; 42MyClass1.c = &apos;It works!&apos;puts MyClass1.c #=&gt; 42# =&gt; undefined method `c=&apos; for MyClass1:Class (NoMethodError) 4.单件类每个单件类只有一个实例，而且不能被继承。单件类也是一个对象单件方法的存活之所。 单件方法适合在什么情况下使用 ​ 仅仅针对于个别使用次数很少的对象。也就是用来增强某个类。 ​ 类方法的实质是一个类的单件方法。 ​ 类方法的实质就是：它们是一个类的单件方法。为什么要是单件方法呢？——只是这一个对象（类）能用它。 怎样进入单件类？ 123class &lt;&lt; an_object # ...end 如果对象有单件类，Ruby不是从它所在的类开始查找，而是从对象的单件类开始查找方法。 在单件类中，有一种运用情况是类方法，下面来看看类方法。 5.三种定义类方法的方法：类扩展通过向类的单件类中增加模块来定义方法。 直接打开类 1234567891011module MyModule def my_method; &quot;Hello&quot;; endendclass MyClass class &lt;&lt; self include MyModule endendputs MyClass.my_method #=&gt; &quot;Hello&quot; include方法扩展： 123456789101112module MyModule def my_method; &quot;Hello&quot;; endendobj = Object.newclass &lt;&lt; obj include MyModuleendputs obj.my_method #=&gt; &quot;Hello&quot;puts obj.singleton_methods #=&gt; &quot;[:my_method]&quot; extend方法扩展： 12345678910111213module MyModule def my_method; &quot;Hello&quot;; endendobj = Object.newobj.extend MyModuleputs obj.my_method #=&gt; &quot;Hello&quot;class MyClass extend MyModuleendputs MyClass.my_method #=&gt; &quot;Hello&quot; 6.方法包装器有一个不能直接修改的方法，而我希望为这个方法包装额外的特性，这样所有的客户端都能自动获得这个额外特性。要明白方法包装器，先明白方法别名： 方法别名 有点绕，先看较简单的初级形式，它只输出一个字符串： 123456789101112class MyClass def my_method &apos;my_method()&apos; end alias_method :m, :my_method alias_method :m2, :mendobj = MyClass.newputs obj.my_methodputs obj.mputs obj.m2 先给方法命名一个别名，然后重定义了它： 12345678910class String alias_method :real_length, :length def length real_length &gt; 5 ? &apos;long&apos; : &apos;short&apos; endendputs &quot;War and Peace&quot;.lengthputs &quot;War and Peace&quot;.real_length 当调用real_length时，它会调用原来的length并输出结果。 调用length时，它会通过real_length与5比较，然后得到结果。同样的，调用real_length时，它会调用原来的length并输出结果。 定义环绕别名 ​ 1.给方法定义一个别名 ​ 2.重定义这个方法 ​ 3.在新的方法中调用老的方法 ​ 它的作用本质是往老方法中加入一些代码。它是一种方法包装器，下面来看看更多的方法包装器： 用细化封装器代替环绕别名 12345678910module StringRefinement refine String do def length super &gt; 5 ? &apos;long&apos; : &apos;short&apos; end endendusing StringRefinementputs &quot;War and Peace&quot;.length #=&gt; &quot;long&quot; ​ 这里的只用一个super关键字调用原来的方法并与5比较得出结果。 ​ 细化封装器的作用范围只到文件末尾处，比环绕别名安全，因为环绕别名是全局性的。 ​ 不过还有一种方法包装的技术，使用module_prepend方法： 下包含包装器： 1234567891011module ExplicitString def length super &gt; 5 ? &apos;long&apos; : &apos;short&apos; endendString.class_eval do prepend ExplicitStringendputs &quot;War and Peace&quot;.length #=&gt; &quot;long&quot; ​ 它也是一种局部化的方法包装器，不过一般认为它比细化包装器和环绕别名都更清晰。]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby元编程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby元编程笔记——代码块]]></title>
    <url>%2F2017%2F09%2F20%2FRuby%E5%85%83%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[本章内容理解：讲了打破封装，随时随地增加或修改变量和方法的技术。 代码块作为“程序中的基本操作元素之一”，是实现下面这些操作的基础： 代码块是闭包，闭包的作用在于，让变量在指定的作用域发挥作用，不会受到作用域外变量的干扰。也在于将变量带到别的作用域。 接下来依次记录块，作用域以及打破封装共享变量的技术操作。 块12345def a_method(a, b) a + yield(a, b)enda_method(1, 2) &#123;|x, y| (x + y) * 3 &#125; #=&gt; 10 通常情况下，如果只有一行，代码块可以通过大括号定义，比如上面的{|x, y| (x + y) * 3 }，若有多行，可以通过def...end来定义。 在调用一个方法时才可以定义一个块。块会被直接传递给这个方法，该方法可以用yield关键字调用这个块。 通过Kernel#block_given?()方法来询问当前的方法调用是否包含块。 1234567def a_method return yield if block_given? &apos;no block&apos;enda_method # &quot;no block&quot;a_method &#123; &quot;here&apos;s a block!&quot; &#125; # &quot;here&apos;s a block!&quot; 可以运行的代码由两部分组成：代码本身和一组绑定。 从上面两个例子可以看出，代码块是闭包，它可以把变量带出原来的作用域，带入a_method中执行。代码块不能孤立地运行，它需要一个执行环境：局部变量，实例变量，self等。可运行的代码包括两部分：代码本身和一组绑定。那么代码块是如何获得一组绑定的呢？ 1234567def my_method x = &quot;Goodbye&quot; yield(&quot;cruel&quot;)endx = &quot;Hello&quot;my_method &#123;|y| &quot;#&#123;x&#125;, #&#123;y&#125; world&quot; &#125; # &quot;Hello, cruel world&quot; 创建代码块时，代码块会获得局部绑定，然后将这两者一起传给一个方法。 还可以在代码块内定义额外的绑定，但这些绑定在代码块结束时就消失了。 12345678910111213141516def just_yield return yield if block_given?endtop_level_variable = 1just_yield do top_level_variable += 1 local_to_block = 1 puts local_to_block # =&gt; 1endputs top_level_variable # =&gt; 2puts local_to_block# =&gt; block_local_vars_failure.rb:24:in `&lt;main&gt;&apos;:# undefined local variable or method `local_to_block&apos; for main:Object (NameError) 基于代码块可以获取局部绑定并一直携带它们的特性，那应该如何使用闭包呢？接下来就要理解作用域了。局部变量之所以被称为局部变量，也是因为它只在自己的作用域内有效。 作用域 作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。 作用域通过作用域门来划分。程序会在作用域门关闭前一个作用域，同时打开一个新的作用域，作用域门有三处地方： 1.类定义。 2.模块定义。 3.方法。 切换作用域下面的例子演示了在程序运行时作用域是怎样切换的，它会用Kernel#local_variables()方法来跟踪绑定的名字： 12345678910111213141516blocks/scopes.rbmodule MyModule # 作用域门：进入module v1 = 1 class MyClass # 作用域门：进入class v2 = 2 local_variables # [:v2] def my_method # 作用域门：进入def v3 = 3 local_variables end # 作用域门：离开def local_variables # [:v2] end # 作用域门：离开classend # 作用域门：离开moduleobj = MyClass.newobj.my_method # [:v3]local_variables # [:v1, :obj] 在一些语言中，比如Java和C#，有“内部作用域（innerscope）”的概念。在内部作用域中可以看到“外部作用域（outerscope）”中的变量。但Ruby中没有这种嵌套式的作用域，它的作用域之间是截然分开的：一旦进入一个新的作用域，原先的绑定就会被替换为一组新的绑定。这意味着在程序进入MyClass后，v1便“超出作用域范围”，从而就不可见了。 几种变量及其作用域： 全局变量 顶级实例变量 局部变量 123456789101112131415161718192021222324252627282930313233343536373839&gt; class A&gt; $var1 = 2 # =&gt; 全局变量&gt; @var = &quot;the top level variable&quot; # =&gt;顶级实例变量&gt; &gt; def my_method&gt; puts @var&gt; var2 = 3&gt; end&gt; &gt; def my_method1&gt; puts var2&gt; # =&gt; NameError: undefined local variable or method `var2&apos; for&gt; # # &lt;A:0x007ffc8f8bfe00&gt; 在my_method中定义的局部变量不能在my_method1中使用&gt; end&gt; end&gt;&gt; class B&gt; def my_method&gt; puts $var1&gt; end&gt; &gt; def my_method1&gt; puts @var2&gt; end &gt; end&gt;&gt; a = A.new&gt; #=&gt; #&lt;A:0x007ffd08900328&gt;&gt; a.my_method&gt; # 没有输出，要由main扮演self的角色，才能有用。而这里的self是对象a&gt; # 所以去掉classA，直接在irb中运行这段代码才可以输出@var&gt;&gt; b = B.new&gt; #=&gt; #&lt;B:0x007fb62584bb78&gt;&gt; b.my_method&gt; #=&gt; 2 # 全局变量可以在任何作用域中访问，所以即使$var1定义在A中，B的my_method方法也可以输出它&gt; b.my_method1&gt; # 没有输出&gt; &gt; 全局变量的问题在于系统的任何部分都可以修改它们。因此，你会立即发现几乎没法追踪谁把它们改成了什么。正因为如此，基本的原则是：如非必要，尽可能少使用全局变量。 你有时可以用顶级实例变量来代替全局变量，只要main对象在扮演self的角色，就可以访问一个顶级实例变量。但当其他对象成为self时，顶级实例变量就退出作用域了。 如果希望让一个变量穿越作用域，那么该怎么做呢？要解答这个问题，还是得回到块的主题上。 如何改变作用域的范围？1.扁平化作用域：1234567my_var = &quot;Success&quot;class MyClass # 你希望在这里打印my_var... def my_method # ..还有这里 endend class这个作用域门。虽然不能让my_var穿越它，但是可以把class关键字替换为某个非作用域门的东西：方法。如果能用方法替换class，就能在一个闭包中获得my_var的值，并把这个闭包传递给该方法。 所以上面的代码可以这样修改： 12345678910my_var = &quot;Success&quot;MyClass = Class.new doputs &quot;# 你希望在这里打印 my_var = #&#123;my_var&#125;&quot; define_method :my_method do puts &quot;# ..还有这里 my_var = #&#123;my_var&#125;&quot; endendmc = MyClass.newputs mc.my_method 这里用了Class.new以及define_method实现扁平作用域，从而实现了变量共享。 扁平化作用域，顾名思义就是把作用域挤压在一起，共享变量。 2.共享作用域假定你想在一组方法之间共享一个变量，但是又不希望其他方法也能访问这个变量，就可以把这些方法定义在那个变量所在的扁平作用域中，这时这个扁平作用域中也叫做共享作用域。 12345678910111213141516def define_methods shared = 0 Kernel.send :define_method, :counter do shared end Kernel.send :define_method, :inc do |x| shared += x endenddefine_methodscounter # =&gt; 0inc(4)counter # =&gt; 4 用自己的话整理了改变作用域操作代码块的操作：1.更改一个类中的实例变量1234567891011121314class MyClass def initialize @v = 1 endendobj = MyClass.new # =&gt; #&lt;MyClass:0x007f93d5852260 @v=1&gt;obj.instance_eval do self #=&gt; #&lt;MyClass:0x007f93d5852260 @v=1&gt; @v #=&gt; 1endv = 2 obj.instance_eval &#123; @v = v &#125;obj.instance_eval &#123; @v &#125; # 2 2.传递一个块到一个方法中12345def a_method(a, b) a + yield(a, b)enda_method(1, 2) &#123;|x, y| (x + y) * 3 &#125; #=&gt; 10 这里就把{|x, y| (x + y) * 3 }传递到a_method方法中，然后用yield求出程序的最终结果。 3.传递一个块的结果到一个到另一个块中123456789101112class CleanRoom def current_temperature 19 endendcr = CleanRoom.newcr.instance_eval do if current_temperature &lt; 20 puts &quot;wear jacket&quot; endend 但是instance_eval无法传递参数，要改用instance_exec，下面的例子比较了它们之间的区别 123456789101112131415161718192021222324252627282930class C def initialize @x = 1 end def my_method @x endendclass D def twisted_method @y = 2 C.new.instance_eval &#123; &quot;@x: #&#123;@x&#125;, @y: #&#123;@y&#125;&quot; &#125; endendputs D.new.twisted_method# =&gt; @x: 1, @y:# 把instance_eval换成instance_execclass D def twisted_method @y = 2 C.new.instance_exec(@y) &#123; |y| &quot;@x: #&#123;@x&#125;, @y: #&#123;y&#125;&quot; &#125; endendputs D.new.twisted_method# =&gt; @x: 1, @y: 2 剖析代码块的底层从底层看，使用代码块分为两步，一是将代码块打包备用，二是是执行被打包的代码。这些打包备用的东西就是可调用对象： 1.块 2.使用proc。proc基本上就是一个由块转换成的对象。 3.使用lambda。它是proc的近亲。 4.使用方法。 Proc对象尽管Ruby中绝大多数东西都是对象，但是块不是。为什么要关心这个呢？设想希望存储[一个块供以后执行]，这时，你需要一个对象才能做到。Bill说道，“为了解决这个问题，Ruby在标准库中提供了名为Proc的类。”一个Proc就是一个转换成对象的块。 123inc = Proc.new &#123;|x| x + 1 &#125;# 更多...inc.call(2) #=&gt;3 这种先打包代码，以后调用的技术称为延迟执行（Deferred Evaluation）。 123dec = lambda &#123;|x| x - 1 &#125;dec.class #=&gt;Procdec.call(2) #=&gt;1 &amp;操作符&amp;操作符能把代码块传递给另一个方法或者代码块。 1234567891011# 这里&#123; |x, y| x * y &#125;就被当成&amp;operation参数传递给do_math方法，随后再被传递给math方法def math(a, b) yield(a, b)enddef do_math(a, b, &amp;operation) math(a, b, &amp;operation)end# puts do_math(2, 3)&#123; |x, y| x * y &#125;puts do_math(2, 3) #=&gt; wrong &amp;操作符会把proc对象my_proc转换为块，再把这个块传给这个方法 123456def my_method(greeting) puts &quot;#&#123;greeting&#125;, #&#123;yield&#125;!&quot;endmy_proc = proc &#123; &quot;Bill&quot; &#125;my_method(&quot;Hello&quot;, &amp;my_proc) Proc和lambda的区别:1.对return的处理不同。12345678910def double(callable_object) callable_object.call * 2endl = lambda &#123; return 10 &#125;double(l) # 20p = Proc.new &#123; return 10 &#125;# 这会失败，并产生一个LocalJumpError错误:# double(p) 2.对参数检查的容忍度不同。1234p = Proc.new&#123; |a, b| [a, b] &#125;p.arity #=&gt; 2p.call(1,2,3) #=&gt; [1, 2]p.call(1) #=&gt; [1, nil] proc根据实际参数的数量自动调整输出结果。再来看lambda 1234ld = lambda&#123; |a, b| [a, b] &#125;ld.arity #=&gt; 2ld.call(1,2,3) #=&gt; ArgumentError: wrong number of arguments (given 3, expected 2)ld.call(1) #=&gt; ArgumentError: wrong number of arguments (given 1, expected 2) 如果参数个数不恰好是两个，就会报错。 方法也是一个可调用对象：1234567891011121314blocks/methods.rbclass MyClass def initialize(value) @x = value end def my_method @x endendobject = MyClass.new(1)m = object.method :my_methodm.call =&gt; # 1 这章知识的运用：开发一个DSL语言，进行几次重构，使代码质量不断进阶： 1.作用域共享 2.变量不要胡乱地散落在顶级作用域里 3.把事件触发条件从代码块转换成proc 4.消灭全局变量，使用共享作用域 5.增加洁净室]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby元编程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby元编程笔记—— 方法]]></title>
    <url>%2F2017%2F09%2F19%2FRuby%E5%85%83%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在理解了方法查找的基础上，可以在运行时创建方法、插入方法调用、把调用转发给其他对象，甚至调用一个不存在的方法。接下来的元编程技术讲解了如何实现这些操作。 本章的主要内容：通过元编程技术使代码更加简洁，更有利于扩展和维护。 先来看一段代码，通过重构的过程，逐步了解元编程怎样发挥作用。 这是一个连接数据库并查询相关信息的data_source类。为节省时间，可直接跳到第三步重构步骤，需要时再跳回来看。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class DS # attr_accessor :workstation_id def initialize &quot;...connect...&quot; end def get_cpu_info(workstation_id) cpu_info = if workstation_id == 1 &quot;intel core i7&quot; else workstation_id == 2 &quot;apple AM 11&quot; end end def get_cpu_price(workstation_id) cpu_price = if workstation_id == 1 2500 else workstation_id == 2 2000 end end def get_mouse_info(workstation_id) mouse_info = if workstation_id == 1 &quot;雷蛇&quot; else workstation_id == 2 &quot;牧马人&quot; end end def get_mouse_price(workstation_id) mouse_price = if workstation_id == 1 300 else workstation_id == 2 500 end end def get_keyboard_info(workstation_id) keyboard_info = if workstation_id == 1 &quot;机械键盘&quot; else workstation_id == 2 &quot;普通键盘&quot; end end def get_keyboard_price(workstation_id) keyboard_price = if workstation_id == 1 500 else workstation_id == 2 90 end endend 这是一个computer类。 12345678910111213141516171819202122232425262728293031323334require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def mouse info = @data_source.get_mouse_info(@id) price = @data_source.get_mouse_price(@id) result = &quot;Mouse: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def cpu info = @data_source.get_cpu_info(@id) price = @data_source.get_cpu_price(@id) result = &quot;Cpu: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def keyboard info = @data_source.get_keyboard_info(@id) price = @data_source.get_keyboard_price(@id) result = &quot;Keyboard: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 endendcomputer = Computer.new(1,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 现在我们使用元编程的技术对Computer类增加动态派发，进行第一次重构： 12345678910111213141516171819202122232425262728293031require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def mouse component :mouse end def cpu component :cpu end def keyboard component :keyboard end def component(name) info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 首先把重复的代码提取到一个方法中，然后把mouse，cpu，keyboard方法代理到component方法上。component方法会接着调用DS类的get_XXX_info和get_XXX_price方法。然后执行相关操作。 现在重复代码被消灭了很多，但仍然可以进一步精简。 什么是动态派发？ 在代码运行的最后一刻再决定调用哪个方法，被称为动态派发。比如@datasource.send “get#{name}_info”, @id的使用。 现在我们使用define_method方法来动态创建方法，以进行第二次重构： 12345678910111213141516171819202122232425require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def self.define_component(name) define_method(name) do info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end end define_component :mouse # 调用第一次创建mouse方法 define_component :cpu # 调用第二次创建cpu方法 define_component :keyboard # 调用第三次创建keyboard方法endcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard define_method可以代替def关键字定义方法，这次重构中，self.define_component(name)方法执行了三次，每一次又都调用define_method分别创建了mouse ，cpu，keyboard方法。然后执行相关操作。 这三个在运行时被定义的方法被称为动态方法。 接下来又有一个关于代码维护和拓展的问题：如果将来DS类中加入了get_display_info方法，而Computer类中并没有动态派发这个方法，能不能在不修改Computer代码的基础上，自动将get_display_info方法加入到Computer的动态派发中呢？ 用内省的方式第三次重构： 1234567891011121314151617181920212223require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source data_source.methods.grep(/^get_(.*)_info$/)&#123; Computer.define_component $1 &#125; end def self.define_component(name) define_method(name) do info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboard 这次重构中新加入的data_source.methods.grep(/^get_(.*)_info$/){ Computer.define_component $1 }的作用如下： 当程序执行到puts computer.mouse时，会去Computer类中去找mouse方法，在initialize中，data_source.methods.grep(/^get_(.*)_info$/)如果找到get_mouse_info方法就会用mouse作为参数传给Computer.define_component，随后Computer.define_component会创建mouse方法。 上面的三次重构用到了动态派发和动态方法的技术。接下来是运用幽灵方法和动态代理来解决代码重构的问题。 第四次重构： 1234567891011121314151617181920212223242526require &apos;./data_source.rb&apos;class Computer def initialize(computer_id, data_source) @id = computer_id @data_source = data_source end def method_missing(name) super if !@data_source.respond_to?(&quot;get_#&#123;name&#125;_info&quot;) info = @data_source.send &quot;get_#&#123;name&#125;_info&quot;, @id price = @data_source.send &quot;get_#&#123;name&#125;_price&quot;, @id result = &quot;#&#123;name.capitalize&#125;: #&#123;info&#125; #&#123;price&#125;&quot; return &quot;#&#123;result&#125;&quot; if price &gt;= 100 end def respond_to_missing?(method, include_private = false) @data_source.respond_to?(&quot;get_#&#123;method&#125;_info&quot;) || super endendcomputer = Computer.new(2,DS.new)puts computer.mouseputs computer.cpuputs computer.keyboardputs computer.respond_to?(:mouse) 当程序执行到puts computer.mouse时，因为computer中没有直接定义mouse方法，所以会调用method_missing方法，如果在@data_source中找到了get_mouse_info，就会用mouse作为参数动态派发get_mouse_info和get_mouse_price执行相应程序返回相应结果。 什么叫幽灵方法？ method_missing 被称作幽灵方法，它可以动态地创建方法。 什么叫动态代理？ 一个捕获幽灵方法调用并把它们转发给另外一个对象的对象（有时也会在转发前后包装一些自己的逻辑，在这里指自己重写的method_missing方法），称为动态代理（Dynamic Proxy）。 当一个幽灵方法和一个真实方法发生名字冲突时这个问题是动态代理技术的通病，当一个幽灵方法和一个真实方法发生名字冲突时，后者会胜出。为了解决这个问题，你可以通过继承白板类和删除重名方法的方法来定义方法。继承白板类: 1class XXX &lt; BasicObject 删除重名方法: 可以使用Module#undef_method()方法，它会删除所有的（包括继承来的）方法；也可以使用Module#remove_method()方法，它只会删除接收者自己的方法，而保留继承来的方法。]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby元编程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
